# 引用与指针
#### 1. 什么是指针?谈谈你对指针的理解?
   - 指针是一个变量，该变量专门存放内存地址；
   - 指针变量的类型取决于其指向的数据类型，在所指数据类型前加*。
   - 指针变量的特点是它可以访问所指向的内存
#### 2. 什么是常指针，什么是指向常变量的指针?
   - 常指针的含义是该指针所指向的地址不能变，但该地址所指向的内容可以变化，使用常指针可以保证我们的指针不能指向其它的变量，
   - 指向常变量的指针是指该指针的变量本身的地址可以变化，可以指向其它的变量，但是它所指的内容不可以被修改。指向长变量的指针定义， 
#### 3. 函数指针和指针函数的区别?
   - 函数指针是指向一个函数入口的指针；指针函数是函数的返回值是一个指针类型。
#### 4. 介绍下this指针?
   - this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
#### 5. 在什么场景下需要显式引用 this 指针?
   - 为实现对象的链式引用
   - 为避免对同一对象进行赋值操作
   - 在实现一些数据结构时，如 list
#### 6. 引用与指针有什么区别？
   - 引用必须被初始化，指针不必。
   - 引用初始化以后不能被改变，指针可以改变所指的对象。
   - 不存在指向空值的引用，但是存在指向空值的指针。   
#### 7. 将“引用”作为函数返回值类型的格式、好处?格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }
   - 好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。
   因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!
#### 8. int const * const p;有一个简便的办法记忆。从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”。
```cpp
    const int p; //常量整数
    const int* p; //p is a point to int const.p是一个指向整型常量的指针
    int const* p; //p is a point to const int 同上
    int * const p;//p is a const point to int.p是一个常量指针，指向整型。
    const int * const p;//p is a const point to int const.
    int const * const p;//p is a const point to const int 同上p都是常量指针，指向整型常量
```


# 多态
#### 1. 多态,虚函数,纯虚函数
   - 多态:以父类的指针或引用,寻址出一个子类对象。
   - 虚函数:在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
   - 纯虚函数：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。
   从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。
   抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。
#### 2. 什么是重写？
   - 指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
      1. 相同的范围（在同一个作用域中） ；
      2. 函数名字相同；
      3. 参数不同；
      4. virtual 关键字可有可无。
      5. 返回值可以不同；
   - 是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）
   - 编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。
   如，有两个同名函数function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关
#### 2. 什么是重载？
  - 是指派生类重新定义基类的虚函数，特征是：
      1. 不在同一个作用域（分别位于派生类与基类） ；
      2. 函数名字相同；
      3. 参数相同；
      4. 基类函数必须有 virtual 关键字，不能有 static 。
      5. 返回值相同（或是协变），否则报错；<—-协变这个概念我也是第一次才知道…
      6. 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的
  - 是指子类重新定义父类虚函数的方法。
  - 和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）
  
  #### 3. 什么时候要用虚析构函数
   - 通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚的。否则其删除效果将无法实现。一般情况下，这样的删除只能够删除基类对象，
   而不能删除子类对象，形成了删除一半形象，从而造成内存泄漏
   - 在公有继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员。如果想要用基类对非继承成员进行操作，
   则要把基类的这个操作（函数）定义为虚函数。那么，析构函数自然也应该如此：如果它想析构子类中的重新定义或新的成员及对象，当然也应该声明为虚的
   - 如果不需要基类对派生类及对象进行操作，则不能定义虚函数（包括虚析构函数），因为这样会增加内存开销。
   
 #### 4. 什么函数不能声明为虚函数？
   - constructor函数不能声明为虚函数
   
 #### 5. 虚函数（virtual）可以是内联函数（inline）吗？
   - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
   - 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
   - inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类如 Base::who()这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
   
# 全局变量和局部变量
#### 1. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
  - 生命周期不同：
    1. 全局变量随主程序创建和创建，随主程序销毁而销毁；
    2. 局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
  - 使用方式不同：
    1. 通过声明后全局变量程序的各个部分都可以用到；
    2. 局部变量只能在局部使用；分配在栈区。
  - 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。
#### 2. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
  - 全局变量储存在静态数据库，局部变量在堆栈。
#### 3. static作用
  - 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统     用默认值初始化它。
  - 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
  - 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
  - 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。
#### 4. 类的 static 变量在什么时候初始化？函数的 static 变量在什么时候初始化？
  - 类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的 static 变量在执行此函数时进行初始化。
#### 5. StaticDataMembers如何存取？
  - StaticDataMembers放在全局变量的表中,并按照一定的解释方式存取。
#### 6. noStaticDataMembers如何存取？
  - 编译器需要把ClassObj的起始地址加上datamember的偏移量。没一个noStaticDataMembers的偏移量(offset)在编译期即可获取。
  
# const与#define与ifndef/define/endif
#### 1. const作用
  - 修饰变量，说明该变量不可以被改变；
  - 修饰指针，分为指向常量的指针和指针常量；
  - 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
  - 修饰成员函数，说明该成员函数内不能修改成员变量。
#### 2. 什么是宏，它解决什么问题？
  - 宏的本质是文本替换，考虑下面的需求，程序中多次使用圆周率Pi，在每个地方都使用3.1415，显然很愚蠢。有没有好的办法呢？使用宏，如下：
　　#define Pi 3.1415
　　这样，编译器在程序中遇到Pi，就使用3.1415来进行文本替换。
#### 3. const 与 #define 相比，有何优点？
  - const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
  - const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生     意料不到的错误。
#### 4. 头文件种的 ifndef/define/endif 是干什么用的
  - 防止头文件被重复包含
# 堆栈
#### 1. 堆栈溢出一般是由什么原因导致的？
  - 没有回收垃圾资源。
#### 2. 堆和栈的区别？堆和栈的生命周期？
  - 堆栈空间分配区别：
    1. 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
    2. 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
  - 堆栈缓存方式区别：
    1. 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
    2. 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
  - 堆栈数据结构区别：
    1. 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
    2. 栈（数据结构）：一种先进后出的数据结构。
 #### 3. 描述内存分配方式以及它们的区别?
  - 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
  - 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
  - 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期     由程序员决定，使用非常灵活，但问题也最多。 
  #### 4. C++中有了malloc / free,为什么还需要 new / delete?
  - malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
  - 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数
  由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free
  - 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
# 关键字
#### 1. sizeof()
  - sizeof 对数组，得到整个数组所占空间大小。
  - sizeof 对指针，得到指针本身所占空间大小。
#### 2. extern "C"
  - 被 extern 限定的函数或变量是 extern 类型的
  - 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
  - extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题
#### 3. delete 与 delete[]区别
  - delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。  
#### 4. C++ 中struct 和class 区别
  - struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。
# 内联函数
#### 1. inline 内联函数特征
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 不能包含循环、递归、switch 等复杂操作；
  - 类中除了虚函数的其他函数都会自动隐式地当成内联函数。
# 构造函数
#### 1. explicit（显式）构造函数
  - explicit 修饰的构造函数可用来防止隐式转换 
    ```cpp
    class Test1
    {
    public:
        Test1(int n)            // 普通构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    class Test2
    {
    public:
        explicit Test2(int n)   // explicit（显式）构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    int main()
    {
        Test1 t1=12;            // 隐式调用其构造函数，成功
        Test2 t2=12;            // 编译错误，不能隐式调用其构造函数
        Test2 t2(12);           // 显式调用成功
        return 0;
    }
    ``` 
#### 2. 编译器如何合成默认构造函数？
  - 在合成的默认构造函数中,只有BaseClassObj和MemberClassObj会被初始化。其他noStaticDataMember如整数,整数指针,整数数组不会被初始化。编译器合成的默认
  构造函数并不能保证每一个datamember都有默认值。
# 静态成员函数与非静态函数
#### 1. memberFunction被内化为noMember形式,转化步骤:
  - 安排*this指针到memberFunction中，提供存取管道，使ClassObj能调用该函数
  - 将每一个对noStaticDataMember的存取操作改为由this指针来存取。
  - 将memberFunction重新写成一个外部函数,对函数名称进行特殊处理使其独一无二。
#### 2. staticmemberFunction被内化为noMember形式:
  - 没有this指针
  - 不能直接存取其Class中的nostaticmembers。
  - 不能声明为const virtual。
  - 不需要经由ClassObj进行调用
    
# 数据结构
#### 1. list和vector的区别
  - vector使用连续内存存储的，他支持[]运算符。Vector对于随机访问的速度很快，但是对于插入尤其是在头部插入元素速度很慢，在尾部插入速度很快
  - list是以链表形式实现的，不支持[]。List对于随机访问速度慢得多，因为可能要遍历整个链表才能做到，但是对于插入就快的多了，不需要拷贝和移动数据，只需要     改变指针的指向就可以了。
#### 2. 什么是平衡二叉树？
  - 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。
# C++与C
#### 1. C和C++的区别？
  - C++在C的基础上增添类
  - C是一个结构化语言，它的重点在于算法和数据结构。
  - C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象     模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
# 其他
#### 1. main 函数执行以前，还会执行什么代码？
  - 全局对象的构造函数会在main 函数之前执行。
#### 2. C++ 编译器自动为类产生的四个缺省函数是什么?
  - 默认构造函数，拷贝构造函数，析构函数，赋值函数。
#### 3. 分别写出 bool,int,float,指针类型的变量 a 与“零”的比较语句。
  ```CPP
  bool : if(!a) or if(a)
  int : if(a==0) 或 if(!a)
  float : const EXPRESSION EXP=0.000001 if (a-EXP)
  pointer : if (a != NULL) or if(a == NULL)
  ```
  
